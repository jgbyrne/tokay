#!/usr/bin/unicc2
# Tokay Programming Language
# (C) 2020 by Jan Max Meyer, Phorward Software Technologies

%skip		/[ \t\r]+/
%skip		/\/\*([^*]|\*[^\/])*\*\//
%skip		/#[^\n]*/
%skip		/\\\n/

<			'=' '+=' '-=' '*=' '/=' '%=' '^='
<           '||'
<           '&&'
<			'==' '!=' '<' '<=' '>' '>='
<           '|'
<           '&'
<			'+' '-'
<			'*'	'/'
<			'%'
<			'^'

@Integer	:	/\d+/
@Float		:	/\d*\.\d+|\d+\.\d*/
@Variable	:=	/[a-z]\w*/
@Constant	:=	/[A-Z_]\w*/
@Identifier	:	/\w+/										# This doesn't work because unicc2 is not context-sensitive

@String 	:	/"[^"]*"/
@LightString:	/'[^']*'/
@Charset	:	/\|[^|]+\|/

@context    :	'$' Identifier 								= context_named
			|	'$' Integer 								= context

@EOL        :	'\n' | ';'

@tail       :	'.' ( Variable = attribute )				# fixme: Should be Identifier!
            |	'[' expr ']'								= index

@lvalue		:=	Variable tail*
			|	context tail*

@call_argument
			:	Variable '=' expr							= arg_variable
			|	Constant '=' constant						= arg_constant
			|	expr										= arg

@call_argument_list
			:	call_argument_list ',' call_argument
            |	call_argument

@call_argument_def
			:	'(' call_argument_list? ')'

@string		:	String										= value_string
			|	LightString									= value_string

@literal	:	Integer										= value_Integer
			|	Float										= value_Float
			|	'true'										= value_boolean_true
			|	'false'										= value_boolean_false
			|	'void'										= value_void
			|	'unset'										= value_unset

@complex	:	'[' EOL* complex_values? EOL* ']'			= complex

@complex_values
			:	complex_value ',' EOL* complex_values?
			|	complex_value EOL*

@complex_value
			:	expr '=' expr								= complex_key_value
			|	expr 										= complex_value

@argument_definition
			:	Constant ('=' constant)?					= argdef_constant
			|	Variable ('=' atomic)?						= argdef_variable

@argument_definition_list
			:	argument_definition_list ',' argument_definition
			|	argument_definition

@argument_definition_def
			:	'(' EOL* argument_definition_list? EOL* ')' EOL*

@block		:	'{' EOL* pattern* '}'

@parselet	:=	'@' argument_definition_def? block

@constant	:	literal
			|	parselet

@assign_expr: 	(Constant '=')+ constant					= define
			|	(lvalue '=')+ expr							= assign
			/*
			|	lvalue '|=' expr							= assign_bitor
			|	lvalue '&=' expr							= assign_bitand
			|	lvalue '+=' expr							= assign_add
			|	lvalue '-=' expr							= assign_sub
			|	lvalue '*=' expr							= assign_mul
			|	lvalue '/=' expr							= assign_div
			|	lvalue '%=' expr							= assign_mod
			|	lvalue '^=' expr							= assign_pow
			*/
			|	lvalue '++' 								= op_unary_post_increment
			|	lvalue '--'									= op_unary_post_decrement
			|	'++' lvalue  								= op_unary_pre_increment
			|	'--' lvalue									= op_unary_pre_decrement

/*
@for_variant:	expr? ';' expr? ';' expr?
			|	Variable "in" expr
*/

@flow_expr	:	'if' (expr = condition) EOL?
					(stmt_or_expr = then) EOL?
			        	('else' EOL? stmt_or_expr = else)?	= if
			/*
			|	'while' expr expr  						    = while
			|	'do' EOL* expr EOL* 'while' expr 	        = do
			|	'for' for_variant EOL* expr      	        = for
			|	'for' '(' EOL* for_variant EOL* ')'
			        EOL* expr 		                        = for

			// Takeover

			|	expr '=>' statement							= takeover
			*/

@binary_expr:	expr '==' expr								= op_binary_eq
			|	expr '!=' expr								= op_binary_uneq
			|	expr '<' expr								= op_binary_lower
			|	expr '<=' expr								= op_binary_lowereq
			|	expr '>' expr								= op_binary_greater
			|	expr '>=' expr								= op_binary_greatereq
			|	expr '||' expr								= op_binary_or
			|	expr '&&' expr								= op_binary_and
		    |	expr '|' expr								= op_binary_bitor
			|	expr '&' expr								= op_binary_bitand
			|	expr '+' expr								= op_binary_add
			|	expr '-' expr								= op_binary_sub
			|	expr '*' expr								= op_binary_mul
			|	expr '/' expr								= op_binary_div
			|	expr '%' expr								= op_binary_mod
			|	expr '^' expr								= op_binary_pow

@unary_expr	:	'!' expr                                    = op_unary_not
			|   '~' expr                                    = op_unary_compl
			|	'-' expr									= op_unary_sub
			|	'+' expr									= op_unary_add

@expr		:

			// Grouped expressions	
				'(' expr ')'
			
			// Flow
			|	flow_expr

			// Operators
			//|	assign_expr
			|	binary_expr
			|	unary_expr

			// Atomics
			|	atomic
			|	string										# string can be here in full expr!

			// Variables
			|	Variable									= rvalue
			|	Constant									= rvalue
			|	context										= rvalue

			//Full-qualified calls
			|	Constant call_argument_def					= call
			|	Variable call_argument_def					= call

@atomic		:	literal
			|	block										= block
			|	parselet
			|	complex

@token		: 	'.'											= call_parselet_builtin_any
			|	'EOF'										= call_parselet_builtin_eof
			|	'Empty'										= call_parselet_builtin_empty
			| 	String										= call_parselet_builtin_match
			| 	LightString									= call_parselet_builtin_touch
			|	Charset										= call_parselet_builtin_chars
			
			// Direct token calls (must be in separate productions to get distinct handle)
			|	Constant call_argument_def?					= call

@modifier	:	token '+'									= mod_positive
			|	token '?'									= mod_optional
			|	token '*'									= mod_kleene
			|	token

@stmt		:	'return' expr?								= return
			|   'accept' expr?								= accept
			|	'extend' expr? 								= extend
			|	'reject'									= reject
			|	'escape'									= escape
			|	'break'										= break
			|	'continue'							    	= continue

@stmt_or_expr
			:	stmt
			|	expr

@action		:	stmt

			// Full-qualified expr must be wrapped!
			|	'(' expr ')'
			
			// Flow
			|	flow_expr

			// Operators
			|	assign_expr
			|	binary_expr
			|	unary_expr

			// Atomics without strings!
			|	atomic

@aliased_token
			:	modifier
			|	modifier ':' Identifier						= alias

@pattern	:	aliased_token* action? EOL?					= pattern
			|	action EOL?
			|	EOL

@tokay$		:	pattern*















/*
Later this is a nice to have...

@constant_expr:
			'(' constant_expr ')'

			| 	constant_expr '==' constant_expr			= op_binary_eq
			|	constant_expr '!=' constant_expr			= op_binary_uneq
			|	constant_expr '<' constant_expr				= op_binary_lower
			|	constant_expr '<=' constant_expr			= op_binary_lowereq
			|	constant_expr '>' constant_expr				= op_binary_greater
			|	constant_expr '>=' constant_expr			= op_binary_greatereq
			|	constant_expr '||' constant_expr			= op_binary_or
			|	constant_expr '&&' constant_expr			= op_binary_and
		    |	constant_expr '|' constant_expr				= op_binary_bitor
			|	constant_expr '&' constant_expr				= op_binary_bitand
			|	constant_expr '+' constant_expr				= op_binary_add
			|	constant_expr '-' constant_expr				= op_binary_sub
			|	constant_expr '*' constant_expr				= op_binary_mul
			|	constant_expr '/' constant_expr				= op_binary_div
			|	constant_expr '%' constant_expr				= op_binary_mod
			|	constant_expr '^' constant_expr				= op_binary_pow
			|   '!' constant_expr							= op_unary_not
			|   '~' constant_expr							= op_unary_compl
			|	'-' constant_expr							= op_unary_sub
			|	'+' constant_expr							= op_unary_add

			|	literal
*/
